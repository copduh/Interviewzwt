import { Router } from 'express';
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import authMiddleware from '../middleware/auth';

// Import text extraction utilities
import pdfParse from 'pdf-parse';
import * as mammoth from 'mammoth';
import { execFile } from 'child_process';
import { promisify } from 'util';

const execFileAsync = promisify(execFile);

const router = Router();

const storage = multer.diskStorage({
  destination: function (req: any, file, cb) {
    const userId = req.user._id.toString();
    const sessionId = req.body.sessionId || 'misc';
    const dir = path.join(__dirname, '../../uploads', userId, sessionId);
    fs.mkdirSync(dir, { recursive: true });
    cb(null, dir);
  },
  filename: function (req, file, cb) {
    cb(null, file.originalname);
  }
});

const upload = multer({ storage });

// Extract text from PDF using pdf-parse
const extractTextFromPDF = async (filePath: string): Promise<string> => {
  try {
    const data = fs.readFileSync(filePath);
    const pdf = await pdfParse(data);
    return pdf.text.trim();
  } catch (error) {
    console.error('Error extracting text from PDF:', error);
    throw new Error('Failed to extract text from PDF');
  }
};

// OCR fallback: convert PDF pages to PNGs with pdftoppm, then run tesseract on each page
const ocrExtractFromPDF = async (filePath: string): Promise<string> => {
  const tmpDir = path.join(path.dirname(filePath), `ocr_${Date.now()}`);
  fs.mkdirSync(tmpDir, { recursive: true });
  const outPrefix = path.join(tmpDir, 'page');

  try {
    // Convert PDF pages to PNG images (requires poppler-utils -> pdftoppm)
    await execFileAsync('pdftoppm', ['-png', '-r', '300', filePath, outPrefix]);

    const images = fs.readdirSync(tmpDir).filter(f => f.toLowerCase().endsWith('.png')).sort();
    if (images.length === 0) throw new Error('No images generated by pdftoppm');

    let fullText = '';
    for (const img of images) {
      const imgPath = path.join(tmpDir, img);
      try {
        // Run tesseract and capture stdout (requires tesseract-ocr installed)
        const { stdout } = await execFileAsync('tesseract', [imgPath, 'stdout', '-l', 'eng']);
        fullText += (stdout || '') + '\n';
      } catch (tErr: any) {
        console.warn('Tesseract failed on image:', imgPath, tErr?.message || tErr);
      }
    }

    return fullText.trim();
  } catch (err: any) {
    console.error('OCR extraction failed:', err?.message || err);
    throw new Error('OCR extraction failed');
  } finally {
    // Cleanup temporary images
    try {
      if (fs.existsSync(tmpDir)) {
        const tmpFiles = fs.readdirSync(tmpDir);
        for (const f of tmpFiles) fs.unlinkSync(path.join(tmpDir, f));
        fs.rmdirSync(tmpDir);
      }
    } catch (cleanupErr) {
      console.warn('Failed to cleanup OCR temp dir:', cleanupErr);
    }
  }
};

// Extract text from DOCX
const extractTextFromDOCX = async (filePath: string): Promise<string> => {
  try {
    const result = await mammoth.extractRawText({ path: filePath });
    return result.value;
  } catch (error) {
    console.error('Error extracting text from DOCX:', error);
    throw new Error('Failed to extract text from DOCX');
  }
};

// Extract text from DOC (basic fallback - convert to text manually)
const extractTextFromDOC = async (filePath: string): Promise<string> => {
  try {
    // For basic DOC files, try to read as text
    const content = fs.readFileSync(filePath, 'utf-8');
    // Remove binary characters
    return content.replace(/[^\x20-\x7E\n\t]/g, '').trim();
  } catch (error) {
    console.error('Error extracting text from DOC:', error);
    throw new Error('Failed to extract text from DOC');
  }
};

router.post('/', authMiddleware, upload.single('file'), async (req: any, res) => {
  if (!req.file) return res.status(400).json({ message: 'No file uploaded' });
  
  const filePath = req.file.path;
  const originalName = req.file.originalname.toLowerCase();
  
  try {
    let extractedText = '';
    
    // Extract based on file type
    if (originalName.endsWith('.pdf')) {
      console.log('Extracting text from PDF:', originalName);
      try {
        extractedText = await extractTextFromPDF(filePath);
      } catch (pdfErr: any) {
        console.warn('pdf-parse failed, attempting OCR fallback for:', originalName, pdfErr?.message || pdfErr);
        try {
          extractedText = await ocrExtractFromPDF(filePath);
        } catch (ocrErr: any) {
          console.error('OCR fallback failed:', ocrErr?.message || ocrErr);
          // rethrow to be caught by outer catch and return 500
          throw new Error('Failed to extract text from PDF (both text-layer and OCR failed)');
        }
      }
    } else if (originalName.endsWith('.docx')) {
      console.log('Extracting text from DOCX:', originalName);
      extractedText = await extractTextFromDOCX(filePath);
    } else if (originalName.endsWith('.doc')) {
      console.log('Extracting text from DOC:', originalName);
      extractedText = await extractTextFromDOC(filePath);
    } else {
      // Try to read as text
      console.log('Attempting to read file as text:', originalName);
      extractedText = fs.readFileSync(filePath, 'utf-8');
    }
    
    if (!extractedText || extractedText.trim().length === 0) {
      console.warn('No text extracted from file:', originalName);
      return res.status(400).json({ 
        message: 'Could not extract text from file. Please ensure it contains readable text.' 
      });
    }
    
    console.log(`Successfully extracted ${extractedText.length} characters from ${originalName}`);
    
    res.json({ 
      filePath, 
      extractedText,
      extractedTextLength: extractedText.length 
    });
  } catch (error: any) {
    console.error('Error processing file:', error);
    res.status(500).json({ 
      message: error.message || 'Error processing file',
      filePath // Return filePath anyway for fallback
    });
  }
});

export default router;
